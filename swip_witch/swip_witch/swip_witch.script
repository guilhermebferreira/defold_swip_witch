local backgrounds = { "bg1", "bg2", "bg3" }
local background_size = 256 * 3
local coin_spawn_interval = 0.15
local enemy_spawn_interval = 2
local powerup_spawn_interval = 6
local magnet_lifetime = 10

local enemy_damage = 10
local max_life = 50


local beginX
local beginY
local endX
local endY

local startTime = 0

local xDistance
local yDistance

go.property("minSwipeDistance", 40)
go.property("minSwipeTime", 0.6)

local doingSwap = 0
local swapSpeed = 200
local bDoingTouch
local totalSwipeDistanceLeft
local totalSwipeDistanceRight
local totalSwipeDistanceUp
local totalSwipeDistanceDown

function init(self)
	msg.post(".", "acquire_input_focus")
	msg.post("camera", "acquire_camera_focus") --part of shake the camera
	math.randomseed(os.time())
	self.coins_collected = 0
	self.life = 10 --life is inscresse with potion and decresse when get damage
	self.speed = 400
	self.powerups = {}
	self.enemys = {}
	self.coins = {}
	self.coins_to_collect = {}
	self.coin_spawn_timer = coin_spawn_interval
	self.powerup_spawn_timer = powerup_spawn_interval
	self.enemy_spawn_timer = enemy_spawn_interval
	self.player_direction = vmath.vector3()
	self.magnet_timer = 0
	msg.post("coinmagnet", "disable")
	msg.post("#coinmagnetcollisionobject", "disable")
end

function final(self)
	msg.post(".", "release_input_focus")
	msg.post("camera", "release_camera_focus") --part of shake the camera
end

function update(self, dt)
	
	msg.post("@render:", "draw_text", { text = "life: ", position = vmath.vector3(20, 40, 0) } )
	msg.post("@render:", "draw_text", { text = self.life, position = vmath.vector3(100, 40, 0) } )
	
	msg.post("@render:", "draw_text", { text = "points: ", position = vmath.vector3(20, 30, 0) } )
	msg.post("@render:", "draw_text", { text = self.coins_collected, position = vmath.vector3(100, 30, 0) } )
	
	-- move background
	for _,bg in pairs(backgrounds) do
		local pos = go.get_position(bg)
		pos = pos + vmath.vector3(0, -self.speed * dt, 0)
		if pos.y <= -background_size then
			pos.y = pos.y + #backgrounds * background_size
		end
		go.set_position(pos, bg)
	end
	
	-- move coins
	for coin,_ in pairs(self.coins) do
		local pos = go.get_position(coin)
		pos = pos + vmath.vector3(0, -self.speed * dt, 0)
		go.set_position(pos, coin)
		if pos.y <= -50 then
			go.delete(coin)
			self.coins[coin] = nil
		end
	end

	-- move powerups
	for powerup,_ in pairs(self.powerups) do
		local pos = go.get_position(powerup)
		pos = pos + vmath.vector3(0, -self.speed * dt, 0)
		go.set_position(pos, powerup)
		if pos.y <= -50 then
			go.delete(powerup)
			self.powerups[powerup] = nil
		end
	end

	-- move enemy
	
	for enemy,_ in pairs(self.enemys) do
		local pos = go.get_position(enemy)
		pos = pos + vmath.vector3(0, -self.speed * dt, 0)
		go.set_position(pos, enemy)
		if pos.y <= -50 then
			go.delete(enemy)
			self.enemys[enemy] = nil
		end
	end
	
	-- spawn coins
	self.coin_spawn_timer = self.coin_spawn_timer - dt
	if self.coin_spawn_timer <= 0 then
		self.coin_spawn_timer = coin_spawn_interval
		local id = factory.create("#coinfactory", vmath.vector3(math.random(20, 620), 1500, 0), nil, {}, 0.25)
		self.coins[id] = true
	end
	
	-- spawn powerups
	self.powerup_spawn_timer = self.powerup_spawn_timer - dt
	if self.powerup_spawn_timer <= 0 then
		self.powerup_spawn_timer = powerup_spawn_interval
		local id = factory.create("#powerupfactory", vmath.vector3(math.random(20, 620), 1500, 0))
		self.powerups[id] = true
	end
	
	-- spawn enemy
	self.enemy_spawn_timer = self.enemy_spawn_timer - dt
	if self.enemy_spawn_timer <= 0 then
		self.enemy_spawn_timer = enemy_spawn_interval
		local id = factory.create("#enemyfactory", vmath.vector3(math.random(20, 620), 1500, 0))
		self.enemys[id] = true
	end
	
	-- move player
	if self.speed > 0 then
		local player_pos = go.get_position() + self.player_direction * swapSpeed * dt
		go.set_position(player_pos)
	
		if doingSwap > 0 then
			-- keep moving
			doingSwap = doingSwap-1
			if doingSwap <= 0 then
				self.player_direction.x = 0
			end
		end
	end
	
		
	
	
	-- collect coins
	for coin,_ in pairs(self.coins_to_collect) do
		local coin_pos = go.get_position(coin)
		local delta = player_pos - coin_pos
		go.set_position(coin_pos + delta * 5 * dt, coin)
		if vmath.length(delta) < 30 then
			go.delete(coin)
			self.coins_to_collect[coin] = nil
		end
	end
	
	
	
	 
	
	
	-- decrease magnet lifetime if active
	if self.magnet_timer > 0 then
		self.magnet_timer = self.magnet_timer - dt
		if self.magnet_timer <= 0 then
			msg.post("coinmagnet", "disable")
			msg.post("#coinmagnetcollisionobject", "disable")
		end
	end
end

function on_message(self, message_id, message, sender)
	
	if message_id == hash("collision_response") then
		if message.group == hash("coin") then
			self.coins[message.other_id] = nil
			--count collected
			get_point(self)
			if self.magnet_timer > 0 then
				self.coins_to_collect[message.other_id] = true
				-- disable the collision object on the coin
				local url = msg.url(message.other_id)
				url.fragment = "collisionobject"
				msg.post(url, "disable")
				
			else
				go.delete(message.other_id)
			end
		elseif message.group == hash("powerup") then
			self.powerups[message.other_id] = nil
			
			go.delete(message.other_id)
			self.magnet_timer = magnet_lifetime
			msg.post("coinmagnet", "enable")
			msg.post("#coinmagnetcollisionobject", "enable")
		
		elseif message.group == hash("enemy") then
			print("Enemy hited")
			get_hited(self)
			
			--self.enemys[message.other_id] = nil
			
			self.enemys[message.other_id] = nil
			go.delete(message.other_id)
			
			--go.delete(message.other_id)
			--go.delete(coin)
			
			--local url = msg.url(message.other_id)
			--url.fragment = "collisionobject"
			--msg.post(url, "disable")
		end
	end
end

function on_input(self, action_id, action)
	if action_id == hash("left") then
		if action.released then
			self.player_direction.x = 0
		else
			self.player_direction.x = -1
		end
	elseif action_id == hash("right") then
		if action.released then
			self.player_direction.x = 0
		else
			self.player_direction.x = 1
		end
	end
  -- reading swipe
  if action_id == hash("click") then
    if action.pressed then
      bDoingTouch = true
      beginX = action.x
      beginY = action.y
      startTime = os.clock()
    elseif action.released  then
      endX = action.x
      endY = action.y
      if os.clock() - startTime < self.minSwipeTime then
      	checkSwipeDirection(self);
      end
      bDoingTouch = false
      --self.player_direction.x = 0
    end
  end
end

function on_reload(self)
    -- Add reload-handling code here
    -- Remove this function if not needed
end

function checkSwipeDirection(self)
  if bDoingTouch == true then
    xDistance =  math.abs(endX - beginX) -- math.abs will return the absolute, or non-negative value, of a given value.
    yDistance =  math.abs(endY - beginY)
    if xDistance > yDistance then
      if beginX > endX then
        totalSwipeDistanceLeft = beginX - endX
        if totalSwipeDistanceLeft > self.minSwipeDistance then
          print("Swiped Left")
          swapSpeed = totalSwipeDistanceLeft
          print(totalSwipeDistanceLeft/10)
          doingSwap = totalSwipeDistanceLeft/10
          self.player_direction.x = -1
           
        end
      else
        totalSwipeDistanceRight = endX - beginX
        if totalSwipeDistanceRight > self.minSwipeDistance then
          print("Swiped Right")
          swapSpeed = totalSwipeDistanceRight
          print(totalSwipeDistanceRight/10)
          doingSwap = totalSwipeDistanceRight/10
          self.player_direction.x = 1
          
        end
      end
    else
     if beginY > endY then
        totalSwipeDistanceUp = beginY - endY
        if totalSwipeDistanceUp > self.minSwipeDistance then
          print("Swiped Down")
        end
       else
        totalSwipeDistanceDown = endY - beginY
        if totalSwipeDistanceDown > self.minSwipeDistance then
          print("Swiped Up")
        end
       end
    end
end

end

function get_point(self)
	self.coins_collected = self.coins_collected + 1
	self.life = self.life + 1
end


function get_hited(self)
	self.life = self.life - enemy_damage
	--shake the screen to visual impact
	msg.post("camera#baturinsky_shake", "shake", { shake = (enemy_damage*10) })
	
	--check if she is alive yet
	if self.life <= 0 then
		self.speed = 0
	end
	
	
end

  